(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.emnapiCore = {}));
})(this, (function (exports) {
    /* eslint-disable no-undef */
    var _WebAssembly$1 = typeof WebAssembly !== 'undefined'
        ? WebAssembly
        : typeof WXWebAssembly !== 'undefined'
            ? WXWebAssembly
            : undefined;
    function validateImports(imports) {
        if (imports && typeof imports !== 'object') {
            throw new TypeError('imports must be an object or undefined');
        }
        return true;
    }
    function load(wasmInput, imports) {
        if (!wasmInput)
            throw new TypeError('Invalid wasm source');
        validateImports(imports);
        imports = imports !== null && imports !== void 0 ? imports : {};
        // Promise<string | URL | Response | BufferSource | WebAssembly.Module>
        try {
            var then = typeof wasmInput === 'object' && wasmInput !== null && 'then' in wasmInput ? wasmInput.then : undefined;
            if (typeof then === 'function') {
                return then.call(wasmInput, function (input) { return load(input, imports); });
            }
        }
        catch (_) { }
        // BufferSource
        if (wasmInput instanceof ArrayBuffer || ArrayBuffer.isView(wasmInput)) {
            return _WebAssembly$1.instantiate(wasmInput, imports);
        }
        // WebAssembly.Module
        if (wasmInput instanceof _WebAssembly$1.Module) {
            return _WebAssembly$1.instantiate(wasmInput, imports).then(function (instance) {
                return { instance: instance, module: wasmInput };
            });
        }
        // Response
        if (typeof Response !== 'undefined' && wasmInput instanceof Response) {
            return wasmInput.arrayBuffer().then(function (buffer) {
                return _WebAssembly$1.instantiate(buffer, imports);
            });
        }
        // string | URL
        var inputIsString = typeof wasmInput === 'string';
        if (inputIsString || (typeof URL !== 'undefined' && wasmInput instanceof URL)) {
            if (inputIsString && typeof wx !== 'undefined' && typeof __wxConfig !== 'undefined') {
                return _WebAssembly$1.instantiate(wasmInput, imports);
            }
            if (typeof fetch !== 'function') {
                throw new TypeError('wasm source can not be a string or URL in this environment');
            }
            if (typeof _WebAssembly$1.instantiateStreaming === 'function') {
                try {
                    return _WebAssembly$1.instantiateStreaming(fetch(wasmInput), imports).catch(function () {
                        return load(fetch(wasmInput), imports);
                    });
                }
                catch (_) {
                    return load(fetch(wasmInput), imports);
                }
            }
            else {
                return load(fetch(wasmInput), imports);
            }
        }
        throw new TypeError('Invalid wasm source');
    }
    function loadSync(wasmInput, imports) {
        if (!wasmInput)
            throw new TypeError('Invalid wasm source');
        validateImports(imports);
        imports = imports !== null && imports !== void 0 ? imports : {};
        var module;
        if ((wasmInput instanceof ArrayBuffer) || ArrayBuffer.isView(wasmInput)) {
            module = new _WebAssembly$1.Module(wasmInput);
        }
        else if (wasmInput instanceof WebAssembly.Module) {
            module = wasmInput;
        }
        else {
            throw new TypeError('Invalid wasm source');
        }
        var instance = new _WebAssembly$1.Instance(module, imports);
        var source = { instance: instance, module: module };
        return source;
    }

    var _WebAssembly = typeof WebAssembly !== 'undefined'
        ? WebAssembly
        : typeof WXWebAssembly !== 'undefined'
            ? WXWebAssembly
            : undefined;
    var ENVIRONMENT_IS_NODE = typeof process === 'object' && process !== null &&
        typeof process.versions === 'object' && process.versions !== null &&
        typeof process.versions.node === 'string';
    function getPostMessage(options) {
        return typeof (options === null || options === void 0 ? void 0 : options.postMessage) === 'function'
            ? options.postMessage
            : typeof postMessage === 'function'
                ? postMessage
                : undefined;
    }
    function serizeErrorToBuffer(sab, code, error) {
        var i32array = new Int32Array(sab);
        Atomics.store(i32array, 0, code);
        if (code > 1 && error) {
            var name_1 = error.name;
            var message = error.message;
            var stack = error.stack;
            var nameBuffer = new TextEncoder().encode(name_1);
            var messageBuffer = new TextEncoder().encode(message);
            var stackBuffer = new TextEncoder().encode(stack);
            Atomics.store(i32array, 1, nameBuffer.length);
            Atomics.store(i32array, 2, messageBuffer.length);
            Atomics.store(i32array, 3, stackBuffer.length);
            var buffer = new Uint8Array(sab);
            buffer.set(nameBuffer, 16);
            buffer.set(messageBuffer, 16 + nameBuffer.length);
            buffer.set(stackBuffer, 16 + nameBuffer.length + messageBuffer.length);
        }
    }
    function deserizeErrorFromBuffer(sab) {
        var _a, _b;
        var i32array = new Int32Array(sab);
        var status = Atomics.load(i32array, 0);
        if (status <= 1) {
            return null;
        }
        var nameLength = Atomics.load(i32array, 1);
        var messageLength = Atomics.load(i32array, 2);
        var stackLength = Atomics.load(i32array, 3);
        var buffer = new Uint8Array(sab);
        var nameBuffer = buffer.slice(16, 16 + nameLength);
        var messageBuffer = buffer.slice(16 + nameLength, 16 + nameLength + messageLength);
        var stackBuffer = buffer.slice(16 + nameLength + messageLength, 16 + nameLength + messageLength + stackLength);
        var name = new TextDecoder().decode(nameBuffer);
        var message = new TextDecoder().decode(messageBuffer);
        var stack = new TextDecoder().decode(stackBuffer);
        var ErrorConstructor = (_a = globalThis[name]) !== null && _a !== void 0 ? _a : (name === 'RuntimeError' ? ((_b = _WebAssembly.RuntimeError) !== null && _b !== void 0 ? _b : Error) : Error);
        var error = new ErrorConstructor(message);
        Object.defineProperty(error, 'stack', {
            value: stack,
            writable: true,
            enumerable: false,
            configurable: true
        });
        return error;
    }
    /** @public */
    function isSharedArrayBuffer(value) {
        return ((typeof SharedArrayBuffer === 'function' && value instanceof SharedArrayBuffer) ||
            (Object.prototype.toString.call(value) === '[object SharedArrayBuffer]'));
    }
    /** @public */
    function isTrapError(e) {
        try {
            return e instanceof _WebAssembly.RuntimeError;
        }
        catch (_) {
            return false;
        }
    }

    function createMessage(type, payload) {
        return {
            __emnapi__: {
                type: type,
                payload: payload
            }
        };
    }

    var WASI_THREADS_MAX_TID = 0x1FFFFFFF;
    function checkSharedWasmMemory(wasmMemory) {
        if (wasmMemory) {
            if (!isSharedArrayBuffer(wasmMemory.buffer)) {
                throw new Error('Multithread features require shared wasm memory. ' +
                    'Try to compile with `-matomics -mbulk-memory` and use `--import-memory --shared-memory` during linking, ' +
                    'then create WebAssembly.Memory with `shared: true` option');
            }
        }
        else {
            if (typeof SharedArrayBuffer === 'undefined') {
                throw new Error('Current environment does not support SharedArrayBuffer, threads are not available!');
            }
        }
    }
    function getReuseWorker(value) {
        var _a;
        if (typeof value === 'boolean') {
            return value ? { size: 0, strict: false } : false;
        }
        if (typeof value === 'number') {
            if (!(value >= 0)) {
                throw new RangeError('reuseWorker: size must be a non-negative integer');
            }
            return { size: value, strict: false };
        }
        if (!value) {
            return false;
        }
        var size = (_a = Number(value.size)) !== null && _a !== void 0 ? _a : 0;
        var strict = Boolean(value.strict);
        if (!(size > 0) && strict) {
            throw new RangeError('reuseWorker: size must be set to positive integer if strict is set to true');
        }
        return { size: size, strict: strict };
    }
    var nextWorkerID = 0;
    /** @public */
    var ThreadManager = /*#__PURE__*/ (function () {
        function ThreadManager(options) {
            var _a;
            this.unusedWorkers = [];
            this.runningWorkers = [];
            this.pthreads = Object.create(null);
            this.wasmModule = null;
            this.wasmMemory = null;
            this.messageEvents = new WeakMap();
            if (!options) {
                throw new TypeError('ThreadManager(): options is not provided');
            }
            if ('childThread' in options) {
                this._childThread = Boolean(options.childThread);
            }
            else {
                this._childThread = false;
            }
            if (this._childThread) {
                this._onCreateWorker = undefined;
                this._reuseWorker = false;
                this._beforeLoad = undefined;
            }
            else {
                this._onCreateWorker = options.onCreateWorker;
                this._reuseWorker = getReuseWorker(options.reuseWorker);
                this._beforeLoad = options.beforeLoad;
            }
            this.printErr = (_a = options.printErr) !== null && _a !== void 0 ? _a : console.error.bind(console);
        }
        Object.defineProperty(ThreadManager.prototype, "nextWorkerID", {
            get: function () { return nextWorkerID; },
            enumerable: false,
            configurable: true
        });
        ThreadManager.prototype.init = function () {
            if (!this._childThread) {
                this.initMainThread();
            }
        };
        ThreadManager.prototype.initMainThread = function () {
            this.preparePool();
        };
        ThreadManager.prototype.preparePool = function () {
            if (this._reuseWorker) {
                if (this._reuseWorker.size) {
                    var pthreadPoolSize = this._reuseWorker.size;
                    while (pthreadPoolSize--) {
                        var worker = this.allocateUnusedWorker();
                        if (ENVIRONMENT_IS_NODE) {
                            // https://github.com/nodejs/node/issues/53036
                            worker.once('message', function () { });
                            worker.unref();
                        }
                    }
                }
            }
        };
        ThreadManager.prototype.shouldPreloadWorkers = function () {
            return !this._childThread && this._reuseWorker && this._reuseWorker.size > 0;
        };
        ThreadManager.prototype.loadWasmModuleToAllWorkers = function () {
            var _this_1 = this;
            var promises = Array(this.unusedWorkers.length);
            var _loop_1 = function (i) {
                var worker = this_1.unusedWorkers[i];
                if (ENVIRONMENT_IS_NODE)
                    worker.ref();
                promises[i] = this_1.loadWasmModuleToWorker(worker).then(function (w) {
                    if (ENVIRONMENT_IS_NODE)
                        worker.unref();
                    return w;
                }, function (e) {
                    if (ENVIRONMENT_IS_NODE)
                        worker.unref();
                    throw e;
                });
            };
            var this_1 = this;
            for (var i = 0; i < this.unusedWorkers.length; ++i) {
                _loop_1(i);
            }
            return Promise.all(promises).catch(function (err) {
                _this_1.terminateAllThreads();
                throw err;
            });
        };
        ThreadManager.prototype.preloadWorkers = function () {
            if (this.shouldPreloadWorkers()) {
                return this.loadWasmModuleToAllWorkers();
            }
            return Promise.resolve([]);
        };
        ThreadManager.prototype.setup = function (wasmModule, wasmMemory) {
            this.wasmModule = wasmModule;
            this.wasmMemory = wasmMemory;
        };
        ThreadManager.prototype.markId = function (worker) {
            if (worker.__emnapi_tid)
                return worker.__emnapi_tid;
            var tid = nextWorkerID + 43;
            nextWorkerID = (nextWorkerID + 1) % (WASI_THREADS_MAX_TID - 42);
            this.pthreads[tid] = worker;
            worker.__emnapi_tid = tid;
            return tid;
        };
        ThreadManager.prototype.returnWorkerToPool = function (worker) {
            var tid = worker.__emnapi_tid;
            if (tid !== undefined) {
                delete this.pthreads[tid];
            }
            this.unusedWorkers.push(worker);
            this.runningWorkers.splice(this.runningWorkers.indexOf(worker), 1);
            delete worker.__emnapi_tid;
            if (ENVIRONMENT_IS_NODE) {
                worker.unref();
            }
        };
        ThreadManager.prototype.loadWasmModuleToWorker = function (worker, sab) {
            var _this_1 = this;
            if (worker.whenLoaded)
                return worker.whenLoaded;
            var err = this.printErr;
            var beforeLoad = this._beforeLoad;
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var _this = this;
            worker.whenLoaded = new Promise(function (resolve, reject) {
                var handleError = function (e) {
                    var message = 'worker sent an error!';
                    if (worker.__emnapi_tid !== undefined) {
                        message = 'worker (tid = ' + worker.__emnapi_tid + ') sent an error!';
                    }
                    if ('message' in e) {
                        err(message + ' ' + e.message);
                        if (e.message.indexOf('RuntimeError') !== -1 || e.message.indexOf('unreachable') !== -1) {
                            try {
                                _this.terminateAllThreads();
                            }
                            catch (_) { }
                        }
                    }
                    else {
                        err(message);
                    }
                    reject(e);
                    throw e;
                };
                var handleMessage = function (data) {
                    if (data.__emnapi__) {
                        var type = data.__emnapi__.type;
                        var payload = data.__emnapi__.payload;
                        if (type === 'loaded') {
                            worker.loaded = true;
                            if (ENVIRONMENT_IS_NODE && !worker.__emnapi_tid) {
                                worker.unref();
                            }
                            resolve(worker);
                            // if (payload.err) {
                            //   err('failed to load in child thread: ' + (payload.err.message || payload.err))
                            // }
                        }
                        else if (type === 'cleanup-thread') {
                            if (payload.tid in _this_1.pthreads) {
                                _this_1.cleanThread(worker, payload.tid);
                            }
                        }
                    }
                };
                worker.onmessage = function (e) {
                    handleMessage(e.data);
                    _this_1.fireMessageEvent(worker, e);
                };
                worker.onerror = handleError;
                if (ENVIRONMENT_IS_NODE) {
                    worker.on('message', function (data) {
                        var _a, _b;
                        (_b = (_a = worker).onmessage) === null || _b === void 0 ? void 0 : _b.call(_a, {
                            data: data
                        });
                    });
                    worker.on('error', function (e) {
                        var _a, _b;
                        (_b = (_a = worker).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, e);
                    });
                    worker.on('detachedExit', function () { });
                }
                if (typeof beforeLoad === 'function') {
                    beforeLoad(worker);
                }
                try {
                    worker.postMessage(createMessage('load', {
                        wasmModule: _this_1.wasmModule,
                        wasmMemory: _this_1.wasmMemory,
                        sab: sab
                    }));
                }
                catch (err) {
                    checkSharedWasmMemory(_this_1.wasmMemory);
                    throw err;
                }
            });
            return worker.whenLoaded;
        };
        ThreadManager.prototype.allocateUnusedWorker = function () {
            var _onCreateWorker = this._onCreateWorker;
            if (typeof _onCreateWorker !== 'function') {
                throw new TypeError('`options.onCreateWorker` is not provided');
            }
            var worker = _onCreateWorker({ type: 'thread', name: 'emnapi-pthread' });
            this.unusedWorkers.push(worker);
            return worker;
        };
        ThreadManager.prototype.getNewWorker = function (sab) {
            if (this._reuseWorker) {
                if (this.unusedWorkers.length === 0) {
                    if (this._reuseWorker.strict) {
                        if (!ENVIRONMENT_IS_NODE) {
                            var err = this.printErr;
                            err('Tried to spawn a new thread, but the thread pool is exhausted.\n' +
                                'This might result in a deadlock unless some threads eventually exit or the code explicitly breaks out to the event loop.');
                            return;
                        }
                    }
                    var worker_1 = this.allocateUnusedWorker();
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.loadWasmModuleToWorker(worker_1, sab);
                }
                return this.unusedWorkers.pop();
            }
            var worker = this.allocateUnusedWorker();
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.loadWasmModuleToWorker(worker, sab);
            return this.unusedWorkers.pop();
        };
        ThreadManager.prototype.cleanThread = function (worker, tid, force) {
            if (!force && this._reuseWorker) {
                this.returnWorkerToPool(worker);
            }
            else {
                delete this.pthreads[tid];
                var index = this.runningWorkers.indexOf(worker);
                if (index !== -1) {
                    this.runningWorkers.splice(index, 1);
                }
                this.terminateWorker(worker);
                delete worker.__emnapi_tid;
            }
        };
        ThreadManager.prototype.terminateWorker = function (worker) {
            var _this_1 = this;
            var _a;
            var tid = worker.__emnapi_tid;
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            worker.terminate();
            (_a = this.messageEvents.get(worker)) === null || _a === void 0 ? void 0 : _a.clear();
            this.messageEvents.delete(worker);
            worker.onmessage = function (e) {
                if (e.data.__emnapi__) {
                    var err = _this_1.printErr;
                    err('received "' + e.data.__emnapi__.type + '" command from terminated worker: ' + tid);
                }
            };
        };
        ThreadManager.prototype.terminateAllThreads = function () {
            for (var i = 0; i < this.runningWorkers.length; ++i) {
                this.terminateWorker(this.runningWorkers[i]);
            }
            for (var i = 0; i < this.unusedWorkers.length; ++i) {
                this.terminateWorker(this.unusedWorkers[i]);
            }
            this.unusedWorkers = [];
            this.runningWorkers = [];
            this.pthreads = Object.create(null);
            this.preparePool();
        };
        ThreadManager.prototype.addMessageEventListener = function (worker, onMessage) {
            var listeners = this.messageEvents.get(worker);
            if (!listeners) {
                listeners = new Set();
                this.messageEvents.set(worker, listeners);
            }
            listeners.add(onMessage);
            return function () {
                listeners === null || listeners === void 0 ? void 0 : listeners.delete(onMessage);
            };
        };
        ThreadManager.prototype.fireMessageEvent = function (worker, e) {
            var listeners = this.messageEvents.get(worker);
            if (!listeners)
                return;
            var err = this.printErr;
            listeners.forEach(function (listener) {
                try {
                    listener(e);
                }
                catch (e) {
                    err(e.stack);
                }
            });
        };
        return ThreadManager;
    }());

    var kIsProxy = Symbol('kIsProxy');
    /** @public */
    function createInstanceProxy(instance, memory) {
        if (instance[kIsProxy])
            return instance;
        // https://github.com/nodejs/help/issues/4102
        var originalExports = instance.exports;
        var createHandler = function (target) {
            var handlers = [
                'apply',
                'construct',
                'defineProperty',
                'deleteProperty',
                'get',
                'getOwnPropertyDescriptor',
                'getPrototypeOf',
                'has',
                'isExtensible',
                'ownKeys',
                'preventExtensions',
                'set',
                'setPrototypeOf'
            ];
            var handler = {};
            var _loop_1 = function (i) {
                var name_1 = handlers[i];
                handler[name_1] = function () {
                    var args = Array.prototype.slice.call(arguments, 1);
                    args.unshift(target);
                    return Reflect[name_1].apply(Reflect, args);
                };
            };
            for (var i = 0; i < handlers.length; i++) {
                _loop_1(i);
            }
            return handler;
        };
        var handler = createHandler(originalExports);
        var _initialize = function () { };
        var _start = function () { return 0; };
        handler.get = function (_target, p, receiver) {
            var _a;
            if (p === 'memory') {
                return (_a = (typeof memory === 'function' ? memory() : memory)) !== null && _a !== void 0 ? _a : Reflect.get(originalExports, p, receiver);
            }
            if (p === '_initialize') {
                return p in originalExports ? _initialize : undefined;
            }
            if (p === '_start') {
                return p in originalExports ? _start : undefined;
            }
            return Reflect.get(originalExports, p, receiver);
        };
        handler.has = function (_target, p) {
            if (p === 'memory')
                return true;
            return Reflect.has(originalExports, p);
        };
        var exportsProxy = new Proxy(Object.create(null), handler);
        return new Proxy(instance, {
            get: function (target, p, receiver) {
                if (p === 'exports') {
                    return exportsProxy;
                }
                if (p === kIsProxy) {
                    return true;
                }
                return Reflect.get(target, p, receiver);
            }
        });
    }

    var patchedWasiInstances = new WeakMap();
    /** @public */
    var WASIThreads = /*#__PURE__*/ (function () {
        function WASIThreads(options) {
            var _this_1 = this;
            if (!options) {
                throw new TypeError('WASIThreads(): options is not provided');
            }
            if (!options.wasi) {
                throw new TypeError('WASIThreads(): options.wasi is not provided');
            }
            patchedWasiInstances.set(this, new WeakSet());
            var wasi = options.wasi;
            patchWasiInstance(this, wasi);
            this.wasi = wasi;
            if ('childThread' in options) {
                this.childThread = Boolean(options.childThread);
            }
            else {
                this.childThread = false;
            }
            this.PThread = undefined;
            if ('threadManager' in options) {
                if (typeof options.threadManager === 'function') {
                    this.PThread = options.threadManager();
                }
                else {
                    this.PThread = options.threadManager;
                }
            }
            else {
                if (!this.childThread) {
                    this.PThread = new ThreadManager(options);
                    this.PThread.init();
                }
            }
            var waitThreadStart = false;
            if ('waitThreadStart' in options) {
                waitThreadStart = typeof options.waitThreadStart === 'number' ? options.waitThreadStart : Boolean(options.waitThreadStart);
            }
            var postMessage = getPostMessage(options);
            if (this.childThread && typeof postMessage !== 'function') {
                throw new TypeError('options.postMessage is not a function');
            }
            this.postMessage = postMessage;
            var wasm64 = Boolean(options.wasm64);
            var onMessage = function (e) {
                if (e.data.__emnapi__) {
                    var type = e.data.__emnapi__.type;
                    var payload = e.data.__emnapi__.payload;
                    if (type === 'spawn-thread') {
                        threadSpawn(payload.startArg, payload.errorOrTid);
                    }
                    else if (type === 'terminate-all-threads') {
                        _this_1.terminateAllThreads();
                    }
                }
            };
            var threadSpawn = function (startArg, errorOrTid) {
                var _a;
                var EAGAIN = 6;
                var isNewABI = errorOrTid !== undefined;
                try {
                    checkSharedWasmMemory(_this_1.wasmMemory);
                }
                catch (err) {
                    (_a = _this_1.PThread) === null || _a === void 0 ? void 0 : _a.printErr(err.stack);
                    if (isNewABI) {
                        var struct_1 = new Int32Array(_this_1.wasmMemory.buffer, errorOrTid, 2);
                        Atomics.store(struct_1, 0, 1);
                        Atomics.store(struct_1, 1, EAGAIN);
                        Atomics.notify(struct_1, 1);
                        return 1;
                    }
                    else {
                        return -EAGAIN;
                    }
                }
                if (!isNewABI) {
                    var malloc = _this_1.wasmInstance.exports.malloc;
                    errorOrTid = wasm64 ? Number(malloc(BigInt(8))) : malloc(8);
                    if (!errorOrTid) {
                        return -48; /* ENOMEM */
                    }
                }
                var _free = _this_1.wasmInstance.exports.free;
                var free = wasm64 ? function (ptr) { _free(BigInt(ptr)); } : _free;
                var struct = new Int32Array(_this_1.wasmMemory.buffer, errorOrTid, 2);
                Atomics.store(struct, 0, 0);
                Atomics.store(struct, 1, 0);
                if (_this_1.childThread) {
                    postMessage(createMessage('spawn-thread', {
                        startArg: startArg,
                        errorOrTid: errorOrTid
                    }));
                    Atomics.wait(struct, 1, 0);
                    var isError = Atomics.load(struct, 0);
                    var result = Atomics.load(struct, 1);
                    if (isNewABI) {
                        return isError;
                    }
                    free(errorOrTid);
                    return isError ? -result : result;
                }
                var shouldWait = waitThreadStart || (waitThreadStart === 0);
                var sab;
                if (shouldWait) {
                    sab = new Int32Array(new SharedArrayBuffer(16 + 8192));
                    Atomics.store(sab, 0, 0);
                }
                var worker;
                var tid;
                var PThread = _this_1.PThread;
                try {
                    worker = PThread.getNewWorker(sab);
                    if (!worker) {
                        throw new Error('failed to get new worker');
                    }
                    PThread.addMessageEventListener(worker, onMessage);
                    tid = PThread.markId(worker);
                    if (ENVIRONMENT_IS_NODE) {
                        worker.ref();
                    }
                    worker.postMessage(createMessage('start', {
                        tid: tid,
                        arg: startArg,
                        sab: sab
                    }));
                    if (shouldWait) {
                        if (typeof waitThreadStart === 'number') {
                            var waitResult = Atomics.wait(sab, 0, 0, waitThreadStart);
                            if (waitResult === 'timed-out') {
                                try {
                                    PThread.cleanThread(worker, tid, true);
                                }
                                catch (_) { }
                                throw new Error('Spawning thread timed out. Please check if the worker is created successfully and if message is handled properly in the worker.');
                            }
                        }
                        else {
                            Atomics.wait(sab, 0, 0);
                        }
                        var r = Atomics.load(sab, 0);
                        if (r > 1) {
                            try {
                                PThread.cleanThread(worker, tid, true);
                            }
                            catch (_) { }
                            throw deserizeErrorFromBuffer(sab.buffer);
                        }
                    }
                }
                catch (e) {
                    Atomics.store(struct, 0, 1);
                    Atomics.store(struct, 1, EAGAIN);
                    Atomics.notify(struct, 1);
                    PThread === null || PThread === void 0 ? void 0 : PThread.printErr(e.stack);
                    if (isNewABI) {
                        return 1;
                    }
                    free(errorOrTid);
                    return -EAGAIN;
                }
                Atomics.store(struct, 0, 0);
                Atomics.store(struct, 1, tid);
                Atomics.notify(struct, 1);
                PThread.runningWorkers.push(worker);
                if (!shouldWait) {
                    worker.whenLoaded.catch(function (err) {
                        delete worker.whenLoaded;
                        PThread.cleanThread(worker, tid, true);
                        throw err;
                    });
                }
                if (isNewABI) {
                    return 0;
                }
                free(errorOrTid);
                return tid;
            };
            this.threadSpawn = threadSpawn;
        }
        WASIThreads.prototype.getImportObject = function () {
            return {
                wasi: {
                    'thread-spawn': this.threadSpawn
                }
            };
        };
        WASIThreads.prototype.setup = function (wasmInstance, wasmModule, wasmMemory) {
            wasmMemory !== null && wasmMemory !== void 0 ? wasmMemory : (wasmMemory = wasmInstance.exports.memory);
            this.wasmInstance = wasmInstance;
            this.wasmMemory = wasmMemory;
            if (this.PThread) {
                this.PThread.setup(wasmModule, wasmMemory);
            }
        };
        WASIThreads.prototype.preloadWorkers = function () {
            if (this.PThread) {
                return this.PThread.preloadWorkers();
            }
            return Promise.resolve([]);
        };
        /**
         * It's ok to call this method to a WASI command module.
         *
         * in child thread, must call this method instead of {@link WASIThreads.start} even if it's a WASI command module
         *
         * @returns A proxied WebAssembly instance if in child thread, other wise the original instance
         */
        WASIThreads.prototype.initialize = function (instance, module, memory) {
            var exports$1 = instance.exports;
            memory !== null && memory !== void 0 ? memory : (memory = exports$1.memory);
            if (this.childThread) {
                instance = createInstanceProxy(instance, memory);
            }
            this.setup(instance, module, memory);
            var wasi = this.wasi;
            if (('_start' in exports$1) && (typeof exports$1._start === 'function')) {
                if (this.childThread) {
                    wasi.start(instance);
                    try {
                        var kStarted = getWasiSymbol(wasi, 'kStarted');
                        wasi[kStarted] = false;
                    }
                    catch (_) { }
                }
                else {
                    setupInstance(wasi, instance);
                }
            }
            else {
                wasi.initialize(instance);
            }
            return instance;
        };
        /**
         * Equivalent to calling {@link WASIThreads.initialize} and then calling {@link WASIInstance.start}
         * ```js
         * this.initialize(instance, module, memory)
         * this.wasi.start(instance)
         * ```
         */
        WASIThreads.prototype.start = function (instance, module, memory) {
            var exports$1 = instance.exports;
            memory !== null && memory !== void 0 ? memory : (memory = exports$1.memory);
            if (this.childThread) {
                instance = createInstanceProxy(instance, memory);
            }
            this.setup(instance, module, memory);
            var exitCode = this.wasi.start(instance);
            return { exitCode: exitCode, instance: instance };
        };
        WASIThreads.prototype.terminateAllThreads = function () {
            var _a;
            if (!this.childThread) {
                (_a = this.PThread) === null || _a === void 0 ? void 0 : _a.terminateAllThreads();
            }
            else {
                this.postMessage(createMessage('terminate-all-threads', {}));
            }
        };
        return WASIThreads;
    }());
    function patchWasiInstance(wasiThreads, wasi) {
        var patched = patchedWasiInstances.get(wasiThreads);
        if (patched.has(wasi)) {
            return;
        }
        var _this = wasiThreads;
        var wasiImport = wasi.wasiImport;
        if (wasiImport) {
            var proc_exit_1 = wasiImport.proc_exit;
            wasiImport.proc_exit = function (code) {
                _this.terminateAllThreads();
                return proc_exit_1.call(this, code);
            };
        }
        if (!_this.childThread) {
            var start_1 = wasi.start;
            if (typeof start_1 === 'function') {
                wasi.start = function (instance) {
                    try {
                        return start_1.call(this, instance);
                    }
                    catch (err) {
                        if (isTrapError(err)) {
                            _this.terminateAllThreads();
                        }
                        throw err;
                    }
                };
            }
        }
        patched.add(wasi);
    }
    function getWasiSymbol(wasi, description) {
        var symbols = Object.getOwnPropertySymbols(wasi);
        var selectDescription = function (description) { return function (s) {
            if (s.description) {
                return s.description === description;
            }
            return s.toString() === "Symbol(".concat(description, ")");
        }; };
        if (Array.isArray(description)) {
            return description.map(function (d) { return symbols.filter(selectDescription(d))[0]; });
        }
        return symbols.filter(selectDescription(description))[0];
    }
    function setupInstance(wasi, instance) {
        var _a = getWasiSymbol(wasi, ['kInstance', 'kSetMemory']), kInstance = _a[0], kSetMemory = _a[1];
        wasi[kInstance] = instance;
        wasi[kSetMemory](instance.exports.memory);
    }

    /** @public */
    var ThreadMessageHandler = /*#__PURE__*/ (function () {
        function ThreadMessageHandler(options) {
            var postMsg = getPostMessage(options);
            if (typeof postMsg !== 'function') {
                throw new TypeError('options.postMessage is not a function');
            }
            this.postMessage = postMsg;
            this.onLoad = options === null || options === void 0 ? void 0 : options.onLoad;
            this.onError = typeof (options === null || options === void 0 ? void 0 : options.onError) === 'function' ? options.onError : function (_type, err) { throw err; };
            this.instance = undefined;
            // this.module = undefined
            this.messagesBeforeLoad = [];
        }
        /** @virtual */
        ThreadMessageHandler.prototype.instantiate = function (data) {
            if (typeof this.onLoad === 'function') {
                return this.onLoad(data);
            }
            throw new Error('ThreadMessageHandler.prototype.instantiate is not implemented');
        };
        /** @virtual */
        ThreadMessageHandler.prototype.handle = function (e) {
            var _this = this;
            var _a;
            if ((_a = e === null || e === void 0 ? void 0 : e.data) === null || _a === void 0 ? void 0 : _a.__emnapi__) {
                var type = e.data.__emnapi__.type;
                var payload_1 = e.data.__emnapi__.payload;
                try {
                    if (type === 'load') {
                        this._load(payload_1);
                    }
                    else if (type === 'start') {
                        this.handleAfterLoad(e, function () {
                            _this._start(payload_1);
                        });
                    }
                }
                catch (err) {
                    this.onError(err, type);
                }
            }
        };
        ThreadMessageHandler.prototype._load = function (payload) {
            var _this = this;
            if (this.instance !== undefined)
                return;
            var source;
            try {
                source = this.instantiate(payload);
            }
            catch (err) {
                this._loaded(err, null, payload);
                return;
            }
            var then = source && 'then' in source ? source.then : undefined;
            if (typeof then === 'function') {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                then.call(source, function (source) { _this._loaded(null, source, payload); }, function (err) { _this._loaded(err, null, payload); });
            }
            else {
                this._loaded(null, source, payload);
            }
        };
        ThreadMessageHandler.prototype._start = function (payload) {
            var wasi_thread_start = this.instance.exports.wasi_thread_start;
            if (typeof wasi_thread_start !== 'function') {
                var err = new TypeError('wasi_thread_start is not exported');
                notifyPthreadCreateResult(payload.sab, 2, err);
                throw err;
            }
            var postMessage = this.postMessage;
            var tid = payload.tid;
            var startArg = payload.arg;
            notifyPthreadCreateResult(payload.sab, 1);
            try {
                wasi_thread_start(tid, startArg);
            }
            catch (err) {
                if (err !== 'unwind') {
                    throw err;
                }
                else {
                    return;
                }
            }
            postMessage(createMessage('cleanup-thread', { tid: tid }));
        };
        ThreadMessageHandler.prototype._loaded = function (err, source, payload) {
            if (err) {
                notifyPthreadCreateResult(payload.sab, 2, err);
                throw err;
            }
            if (source == null) {
                var err_1 = new TypeError('onLoad should return an object');
                notifyPthreadCreateResult(payload.sab, 2, err_1);
                throw err_1;
            }
            var instance = source.instance;
            if (!instance) {
                var err_2 = new TypeError('onLoad should return an object which includes "instance"');
                notifyPthreadCreateResult(payload.sab, 2, err_2);
                throw err_2;
            }
            this.instance = instance;
            var postMessage = this.postMessage;
            postMessage(createMessage('loaded', {}));
            var messages = this.messagesBeforeLoad;
            this.messagesBeforeLoad = [];
            for (var i = 0; i < messages.length; i++) {
                var data = messages[i];
                this.handle({ data: data });
            }
        };
        ThreadMessageHandler.prototype.handleAfterLoad = function (e, f) {
            if (this.instance !== undefined) {
                f.call(this, e);
            }
            else {
                this.messagesBeforeLoad.push(e.data);
            }
        };
        return ThreadMessageHandler;
    }());
    function notifyPthreadCreateResult(sab, result, error) {
        if (sab) {
            serizeErrorToBuffer(sab.buffer, result, error);
            Atomics.notify(sab, 0);
        }
    }

    function createNapiModule(options) {
        var napiModule = (function () {
            var ENVIRONMENT_IS_NODE = typeof process === 'object' && process !== null && typeof process.versions === 'object' && process.versions !== null && typeof process.versions.node === 'string';
            var ENVIRONMENT_IS_PTHREAD = Boolean(options.childThread);
            var waitThreadStart = typeof options.waitThreadStart === 'number' ? options.waitThreadStart : Boolean(options.waitThreadStart);
            var wasmInstance;
            var wasmMemory;
            var wasmTable;
            var _malloc;
            var _free;
            function abort(msg) {
                if (typeof _WebAssembly$1.RuntimeError === 'function') {
                    throw new _WebAssembly$1.RuntimeError(msg);
                }
                throw Error(msg);
            }
            var napiModule = {
                imports: {
                    env: {},
                    napi: {},
                    emnapi: {}
                },
                exports: {},
                emnapi: {},
                loaded: false,
                filename: '',
                childThread: ENVIRONMENT_IS_PTHREAD,
                initWorker: undefined,
                executeAsyncWork: undefined,
                waitThreadStart: waitThreadStart,
                PThread: undefined,
                init: function (options) {
                    if (napiModule.loaded)
                        return napiModule.exports;
                    if (!options)
                        throw new TypeError('Invalid napi init options');
                    var instance = options.instance;
                    if (!(instance === null || instance === void 0 ? void 0 : instance.exports))
                        throw new TypeError('Invalid wasm instance');
                    wasmInstance = instance;
                    var exports$1 = instance.exports;
                    var module = options.module;
                    var memory = options.memory || exports$1.memory;
                    var table = options.table || exports$1.__indirect_function_table;
                    if (!(module instanceof _WebAssembly$1.Module))
                        throw new TypeError('Invalid wasm module');
                    if (!(memory instanceof _WebAssembly$1.Memory))
                        throw new TypeError('Invalid wasm memory');
                    if (!(table instanceof _WebAssembly$1.Table))
                        throw new TypeError('Invalid wasm table');
                    wasmMemory = memory;
                    wasmTable = table;
                    if (typeof exports$1.malloc !== 'function')
                        throw new TypeError('malloc is not exported');
                    if (typeof exports$1.free !== 'function')
                        throw new TypeError('free is not exported');
                    _malloc = exports$1.malloc;
                    _free = exports$1.free;
                    if (!napiModule.childThread) {
                        // main thread only
                        var moduleApiVersion = 8 /* Version.NODE_API_DEFAULT_MODULE_API_VERSION */;
                        var node_api_module_get_api_version_v1 = instance.exports.node_api_module_get_api_version_v1;
                        if (typeof node_api_module_get_api_version_v1 === 'function') {
                            moduleApiVersion = node_api_module_get_api_version_v1();
                        }
                        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                        var envObject = napiModule.envObject || (napiModule.envObject = emnapiCtx.createEnv(napiModule.filename, moduleApiVersion, function (cb) { return (wasmTable.get(cb)); }, function (cb) { return (wasmTable.get(cb)); }, abort, emnapiNodeBinding));
                        var scope_1 = emnapiCtx.openScope(envObject);
                        try {
                            envObject.callIntoModule(function (_envObject) {
                                var exports$1 = napiModule.exports;
                                var exportsHandle = scope_1.add(exports$1);
                                var napi_register_wasm_v1 = instance.exports.napi_register_wasm_v1;
                                var napiValue = napi_register_wasm_v1(_envObject.id, exportsHandle.id);
                                napiModule.exports = (!napiValue) ? exports$1 : emnapiCtx.handleStore.get(napiValue).value;
                            });
                        }
                        catch (e) {
                            if (e !== 'unwind') {
                                throw e;
                            }
                        }
                        finally {
                            emnapiCtx.closeScope(envObject, scope_1);
                        }
                        napiModule.loaded = true;
                        delete napiModule.envObject;
                        return napiModule.exports;
                    }
                }
            };
            var emnapiCtx;
            var emnapiNodeBinding;
            var onCreateWorker = undefined;
            var err;
            if (!ENVIRONMENT_IS_PTHREAD) {
                var context = options.context;
                if (typeof context !== 'object' || context === null) {
                    throw new TypeError("Invalid `options.context`. Use `import { getDefaultContext } from '@emnapi/runtime'`");
                }
                emnapiCtx = context;
            }
            else {
                emnapiCtx = options === null || options === void 0 ? void 0 : options.context;
                var postMsg = typeof options.postMessage === 'function'
                    ? options.postMessage
                    : typeof postMessage === 'function'
                        ? postMessage
                        : undefined;
                if (typeof postMsg !== 'function') {
                    throw new TypeError('No postMessage found');
                }
                napiModule.postMessage = postMsg;
            }
            if (typeof options.filename === 'string') {
                napiModule.filename = options.filename;
            }
            if (typeof options.onCreateWorker === 'function') {
                onCreateWorker = options.onCreateWorker;
            }
            if (typeof options.print === 'function') {
                options.print;
            }
            else {
                console.log.bind(console);
            }
            if (typeof options.printErr === 'function') {
                err = options.printErr;
            }
            else {
                err = console.warn.bind(console);
            }
            if ('nodeBinding' in options) {
                var nodeBinding = options.nodeBinding;
                if (typeof nodeBinding !== 'object' || nodeBinding === null) {
                    throw new TypeError('Invalid `options.nodeBinding`. Use @emnapi/node-binding package');
                }
                emnapiNodeBinding = nodeBinding;
            }
            var emnapiAsyncWorkPoolSize = 0;
            if ('asyncWorkPoolSize' in options) {
                if (typeof options.asyncWorkPoolSize !== 'number') {
                    throw new TypeError('options.asyncWorkPoolSize must be a integer');
                }
                emnapiAsyncWorkPoolSize = options.asyncWorkPoolSize >> 0;
                if (emnapiAsyncWorkPoolSize > 1024) {
                    emnapiAsyncWorkPoolSize = 1024;
                }
                else if (emnapiAsyncWorkPoolSize < -1024) {
                    emnapiAsyncWorkPoolSize = -1024;
                }
            }
            var singleThreadAsyncWork = ENVIRONMENT_IS_PTHREAD ? false : (emnapiAsyncWorkPoolSize <= 0);
            function _emnapi_async_work_pool_size() {
                return Math.abs(emnapiAsyncWorkPoolSize);
            }
            napiModule.imports.env._emnapi_async_work_pool_size = _emnapi_async_work_pool_size;
            // ------------------------------ pthread -------------------------------
            function emnapiAddSendListener(worker) {
                if (!worker)
                    return false;
                if (worker._emnapiSendListener)
                    return true;
                var handler = function (e) {
                    var data = ENVIRONMENT_IS_NODE ? e : e.data;
                    var __emnapi__ = data.__emnapi__;
                    if (__emnapi__ && __emnapi__.type === 'async-send') {
                        if (ENVIRONMENT_IS_PTHREAD) {
                            var postMessage_1 = napiModule.postMessage;
                            postMessage_1({ __emnapi__: __emnapi__ });
                        }
                        else {
                            // eslint-disable-next-line @typescript-eslint/no-unused-vars
                            var callback = __emnapi__.payload.callback;
                            (wasmTable.get(callback))(__emnapi__.payload.data);
                        }
                    }
                };
                var dispose = function () {
                    if (ENVIRONMENT_IS_NODE) {
                        worker.off('message', handler);
                    }
                    else {
                        worker.removeEventListener('message', handler, false);
                    }
                    delete worker._emnapiSendListener;
                };
                worker._emnapiSendListener = { handler: handler, dispose: dispose };
                if (ENVIRONMENT_IS_NODE) {
                    worker.on('message', handler);
                }
                else {
                    worker.addEventListener('message', handler, false);
                }
                return true;
            }
            napiModule.emnapi.addSendListener = emnapiAddSendListener;
            var PThread = new ThreadManager(ENVIRONMENT_IS_PTHREAD
                ? {
                    printErr: err,
                    childThread: true
                }
                : {
                    printErr: err,
                    beforeLoad: function (worker) {
                        emnapiAddSendListener(worker);
                    },
                    reuseWorker: options.reuseWorker,
                    onCreateWorker: onCreateWorker
                });
            napiModule.PThread = PThread;
            /**
             * @__sig ipiip
             */
            function napi_set_last_error(env, error_code, engine_error_code, engine_reserved) {
                var envObject = emnapiCtx.envStore.get(env);
                return envObject.setLastError(error_code, engine_error_code, engine_reserved);
            }
            /**
             * @__sig ip
             */
            function napi_clear_last_error(env) {
                var envObject = emnapiCtx.envStore.get(env);
                return envObject.clearLastError();
            }
            /**
             * @__sig vppp
             */
            function _emnapi_get_node_version(major, minor, patch) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var versions = (typeof process === 'object' && process !== null &&
                    typeof process.versions === 'object' && process.versions !== null &&
                    typeof process.versions.node === 'string')
                    ? process.versions.node.split('.').map(function (n) { return Number(n); })
                    : [0, 0, 0];
                var HEAP_DATA_VIEW = new DataView(wasmMemory.buffer);
                HEAP_DATA_VIEW.setUint32(major, versions[0], true);
                HEAP_DATA_VIEW.setUint32(minor, versions[1], true);
                HEAP_DATA_VIEW.setUint32(patch, versions[2], true);
            }
            /**
             * @__sig v
             * @__deps $runtimeKeepalivePush
             */
            function _emnapi_runtime_keepalive_push() {
            }
            /**
             * @__sig v
             * @__deps $runtimeKeepalivePop
             */
            function _emnapi_runtime_keepalive_pop() {
            }
            /**
             * @__sig vpp
             */
            function _emnapi_set_immediate(callback, data) {
                emnapiCtx.feature.setImmediate(function () {
                    (wasmTable.get(callback))(data);
                });
            }
            /**
             * @__sig vpp
             */
            function _emnapi_next_tick(callback, data) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                Promise.resolve().then(function () {
                    (wasmTable.get(callback))(data);
                });
            }
            /**
             * @__sig vipppi
             */
            function _emnapi_callback_into_module(forceUncaught, env, callback, data, close_scope_if_throw) {
                var envObject = emnapiCtx.envStore.get(env);
                var scope = emnapiCtx.openScope(envObject);
                try {
                    envObject.callbackIntoModule(Boolean(forceUncaught), function () {
                        (wasmTable.get(callback))(env, data);
                    });
                }
                catch (err) {
                    emnapiCtx.closeScope(envObject, scope);
                    if (close_scope_if_throw) {
                        emnapiCtx.closeScope(envObject);
                    }
                    throw err;
                }
                emnapiCtx.closeScope(envObject, scope);
            }
            /**
             * @__sig vipppp
             */
            function _emnapi_call_finalizer(forceUncaught, env, callback, data, hint) {
                var envObject = emnapiCtx.envStore.get(env);
                envObject.callFinalizerInternal(forceUncaught, callback, data, hint);
            }
            /**
             * @__sig v
             */
            function _emnapi_ctx_increase_waiting_request_counter() {
                emnapiCtx.increaseWaitingRequestCounter();
            }
            /**
             * @__sig v
             */
            function _emnapi_ctx_decrease_waiting_request_counter() {
                emnapiCtx.decreaseWaitingRequestCounter();
            }
            /**
             * @__sig i
             */
            function _emnapi_is_main_runtime_thread() {
                return ENVIRONMENT_IS_PTHREAD ? 0 : 1;
            }
            /**
             * @__sig i
             */
            function _emnapi_is_main_browser_thread() {
                return (typeof window !== 'undefined' && typeof document !== 'undefined' && !ENVIRONMENT_IS_NODE) ? 1 : 0;
            }
            /**
             * @__sig v
             */
            function _emnapi_unwind() {
                // eslint-disable-next-line @typescript-eslint/no-throw-literal
                throw 'unwind';
            }
            /**
             * @__sig d
             */
            function _emnapi_get_now() {
                return performance.timeOrigin + performance.now();
            }
            function $emnapiSetValueI64(result, numberValue) {
                var tempDouble;
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var tempI64 = [
                    numberValue >>> 0,
                    (tempDouble = numberValue, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)
                ];
                var HEAP_DATA_VIEW = new DataView(wasmMemory.buffer);
                HEAP_DATA_VIEW.setInt32(result, tempI64[0], true);
                HEAP_DATA_VIEW.setInt32(result + 4, tempI64[1], true);
            }
            /**
             * @__deps $emnapiCtx
             * @__sig p
             */
            function _emnapi_open_handle_scope() {
                return emnapiCtx.openScope().id;
            }
            /**
             * @__deps $emnapiCtx
             * @__sig vp
             */
            function _emnapi_close_handle_scope(_scope) {
                return emnapiCtx.closeScope();
            }
            var utilMod = /*#__PURE__*/ Object.freeze({
                __proto__: null,
                $emnapiSetValueI64: $emnapiSetValueI64,
                _emnapi_call_finalizer: _emnapi_call_finalizer,
                _emnapi_callback_into_module: _emnapi_callback_into_module,
                _emnapi_close_handle_scope: _emnapi_close_handle_scope,
                _emnapi_ctx_decrease_waiting_request_counter: _emnapi_ctx_decrease_waiting_request_counter,
                _emnapi_ctx_increase_waiting_request_counter: _emnapi_ctx_increase_waiting_request_counter,
                _emnapi_get_node_version: _emnapi_get_node_version,
                _emnapi_get_now: _emnapi_get_now,
                _emnapi_is_main_browser_thread: _emnapi_is_main_browser_thread,
                _emnapi_is_main_runtime_thread: _emnapi_is_main_runtime_thread,
                _emnapi_next_tick: _emnapi_next_tick,
                _emnapi_open_handle_scope: _emnapi_open_handle_scope,
                _emnapi_runtime_keepalive_pop: _emnapi_runtime_keepalive_pop,
                _emnapi_runtime_keepalive_push: _emnapi_runtime_keepalive_push,
                _emnapi_set_immediate: _emnapi_set_immediate,
                _emnapi_unwind: _emnapi_unwind,
                napi_clear_last_error: napi_clear_last_error,
                napi_set_last_error: napi_set_last_error
            });
            function emnapiGetWorkerByPthreadPtr(pthreadPtr) {
                var view = new DataView(wasmMemory.buffer);
                /**
                 * wasi-sdk-20.0+threads
                 *
                 * struct pthread {
                 *   struct pthread *self;        // 0
                 *   struct pthread *prev, *next; // 4, 8
                 *   uintptr_t sysinfo;           // 12
                 *   uintptr_t canary;            // 16
                 *   int tid;                     // 20
                 *   // ...
                 * }
                 */
                var tidOffset = 20;
                var tid = view.getInt32(pthreadPtr + tidOffset, true);
                var worker = PThread.pthreads[tid];
                return worker;
            }
            /** @__sig vp */
            function _emnapi_worker_unref(pthreadPtr) {
                if (ENVIRONMENT_IS_PTHREAD)
                    return;
                var worker = emnapiGetWorkerByPthreadPtr(pthreadPtr);
                if (worker && typeof worker.unref === 'function') {
                    worker.unref();
                }
            }
            /** @__sig vipp */
            function _emnapi_async_send_js(type, callback, data) {
                if (ENVIRONMENT_IS_PTHREAD) {
                    var postMessage_1 = napiModule.postMessage;
                    postMessage_1({
                        __emnapi__: {
                            type: 'async-send',
                            payload: {
                                callback: callback,
                                data: data
                            }
                        }
                    });
                }
                else {
                    switch (type) {
                        case 0:
                            _emnapi_set_immediate(callback, data);
                            break;
                        case 1:
                            _emnapi_next_tick(callback, data);
                            break;
                    }
                }
            }
            // function ptrToString (ptr: number): string {
            //   return '0x' + ('00000000' + ptr.toString(16)).slice(-8)
            // }
            var uvThreadpoolReadyResolve;
            var uvThreadpoolReady = new Promise(function (resolve) {
                uvThreadpoolReadyResolve = function () {
                    uvThreadpoolReady.ready = true;
                    resolve();
                };
            });
            uvThreadpoolReady.ready = false;
            /** @__sig vppi */
            function _emnapi_after_uvthreadpool_ready(callback, q, type) {
                if (uvThreadpoolReady.ready) {
                    (wasmTable.get(callback))(q, type);
                }
                else {
                    uvThreadpoolReady.then(function () {
                        (wasmTable.get(callback))(q, type);
                    });
                }
            }
            /** @__sig vpi */
            function _emnapi_tell_js_uvthreadpool(threads, size) {
                var p = [];
                var HEAP_DATA_VIEW = new DataView(wasmMemory.buffer);
                var _loop_1 = function (i) {
                    var pthreadPtr = HEAP_DATA_VIEW.getUint32(threads + i * 4, true);
                    var worker = emnapiGetWorkerByPthreadPtr(pthreadPtr);
                    p.push(new Promise(function (resolve) {
                        var handler = function (e) {
                            var data = ENVIRONMENT_IS_NODE ? e : e.data;
                            var __emnapi__ = data.__emnapi__;
                            if (__emnapi__ && __emnapi__.type === 'async-thread-ready') {
                                resolve();
                                if (worker && typeof worker.unref === 'function') {
                                    worker.unref();
                                }
                                if (ENVIRONMENT_IS_NODE) {
                                    worker.off('message', handler);
                                }
                                else {
                                    worker.removeEventListener('message', handler);
                                }
                            }
                        };
                        if (ENVIRONMENT_IS_NODE) {
                            worker.on('message', handler);
                        }
                        else {
                            worker.addEventListener('message', handler);
                        }
                    }));
                };
                for (var i = 0; i < size; i++) {
                    _loop_1(i);
                }
                Promise.all(p).then(uvThreadpoolReadyResolve);
            }
            /** @__sig v */
            function _emnapi_emit_async_thread_ready() {
                if (!ENVIRONMENT_IS_PTHREAD)
                    return;
                var postMessage = napiModule.postMessage;
                postMessage({
                    __emnapi__: {
                        type: 'async-thread-ready',
                        payload: {}
                    }
                });
            }
            var asyncMod = /*#__PURE__*/ Object.freeze({
                __proto__: null,
                _emnapi_after_uvthreadpool_ready: _emnapi_after_uvthreadpool_ready,
                _emnapi_async_send_js: _emnapi_async_send_js,
                _emnapi_emit_async_thread_ready: _emnapi_emit_async_thread_ready,
                _emnapi_tell_js_uvthreadpool: _emnapi_tell_js_uvthreadpool,
                _emnapi_worker_unref: _emnapi_worker_unref
            });
            /* eslint-disable @typescript-eslint/indent */
            /** @__sig ipjp */
            function napi_adjust_external_memory(env, change_in_bytes, adjusted_value) {
                if (!env)
                    return 1 /* napi_status.napi_invalid_arg */;
                var envObject = emnapiCtx.envStore.get(env);
                if (!adjusted_value)
                    return envObject.setLastError(1 /* napi_status.napi_invalid_arg */);
                var change_in_bytes_number = Number(change_in_bytes);
                if (change_in_bytes_number < 0) {
                    return envObject.setLastError(1 /* napi_status.napi_invalid_arg */);
                }
                var old_size = wasmMemory.buffer.byteLength;
                var new_size = old_size + change_in_bytes_number;
                new_size = new_size + ((65536 - new_size % 65536) % 65536);
                if (wasmMemory.grow((new_size - old_size + 65535) >> 16) === -1) {
                    return envObject.setLastError(9 /* napi_status.napi_generic_failure */);
                }
                if (emnapiCtx.feature.supportBigInt) {
                    var HEAP_DATA_VIEW = new DataView(wasmMemory.buffer);
                    HEAP_DATA_VIEW.setBigInt64(adjusted_value, BigInt(wasmMemory.buffer.byteLength), true);
                }
                else {
                    $emnapiSetValueI64(adjusted_value, wasmMemory.buffer.byteLength);
                }
                return envObject.clearLastError();
            }
            var memoryMod = /*#__PURE__*/ Object.freeze({
                __proto__: null,
                napi_adjust_external_memory: napi_adjust_external_memory
            });
            /**
             * @__postset
             * ```
             * emnapiAWST.init();
             * ```
             */
            var emnapiAWST = {
                idGen: {},
                values: [undefined],
                queued: new Set(),
                pending: [],
                init: function () {
                    var idGen = {
                        nextId: 1,
                        list: [],
                        generate: function () {
                            var id;
                            if (idGen.list.length) {
                                id = idGen.list.shift();
                            }
                            else {
                                id = idGen.nextId;
                                idGen.nextId++;
                            }
                            return id;
                        },
                        reuse: function (id) {
                            idGen.list.push(id);
                        }
                    };
                    emnapiAWST.idGen = idGen;
                    emnapiAWST.values = [undefined];
                    emnapiAWST.queued = new Set();
                    emnapiAWST.pending = [];
                },
                create: function (env, resource, resourceName, execute, complete, data) {
                    var asyncId = 0;
                    var triggerAsyncId = 0;
                    if (emnapiNodeBinding) {
                        var asyncContext = emnapiNodeBinding.node.emitAsyncInit(resource, resourceName, -1);
                        asyncId = asyncContext.asyncId;
                        triggerAsyncId = asyncContext.triggerAsyncId;
                    }
                    var id = emnapiAWST.idGen.generate();
                    emnapiAWST.values[id] = {
                        env: env,
                        id: id,
                        resource: resource,
                        asyncId: asyncId,
                        triggerAsyncId: triggerAsyncId,
                        status: 0,
                        execute: execute,
                        complete: complete,
                        data: data
                    };
                    return id;
                },
                callComplete: function (work, status) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var complete = work.complete;
                    var env = work.env;
                    var data = work.data;
                    var callback = function () {
                        if (!complete)
                            return;
                        var envObject = emnapiCtx.envStore.get(env);
                        var scope = emnapiCtx.openScope(envObject);
                        try {
                            envObject.callbackIntoModule(true, function () {
                                (wasmTable.get(complete))(env, status, data);
                            });
                        }
                        finally {
                            emnapiCtx.closeScope(envObject, scope);
                        }
                    };
                    if (emnapiNodeBinding) {
                        emnapiNodeBinding.node.makeCallback(work.resource, callback, [], {
                            asyncId: work.asyncId,
                            triggerAsyncId: work.triggerAsyncId
                        });
                    }
                    else {
                        callback();
                    }
                },
                queue: function (id) {
                    var work = emnapiAWST.values[id];
                    if (!work)
                        return;
                    if (work.status === 0) {
                        work.status = 1;
                        if (emnapiAWST.queued.size >= (Math.abs(emnapiAsyncWorkPoolSize) || 4)) {
                            emnapiAWST.pending.push(id);
                            return;
                        }
                        emnapiAWST.queued.add(id);
                        var env_1 = work.env;
                        var data_1 = work.data;
                        // eslint-disable-next-line @typescript-eslint/no-unused-vars
                        var execute = work.execute;
                        work.status = 2;
                        emnapiCtx.feature.setImmediate(function () {
                            (wasmTable.get(execute))(env_1, data_1);
                            emnapiAWST.queued.delete(id);
                            work.status = 3;
                            emnapiCtx.feature.setImmediate(function () {
                                emnapiAWST.callComplete(work, 0 /* napi_status.napi_ok */);
                            });
                            if (emnapiAWST.pending.length > 0) {
                                var nextWorkId = emnapiAWST.pending.shift();
                                emnapiAWST.values[nextWorkId].status = 0;
                                emnapiAWST.queue(nextWorkId);
                            }
                        });
                    }
                },
                cancel: function (id) {
                    var index = emnapiAWST.pending.indexOf(id);
                    if (index !== -1) {
                        var work_1 = emnapiAWST.values[id];
                        if (work_1 && (work_1.status === 1)) {
                            work_1.status = 4;
                            emnapiAWST.pending.splice(index, 1);
                            emnapiCtx.feature.setImmediate(function () {
                                emnapiAWST.callComplete(work_1, 11 /* napi_status.napi_cancelled */);
                            });
                            return 0 /* napi_status.napi_ok */;
                        }
                        else {
                            return 9 /* napi_status.napi_generic_failure */;
                        }
                    }
                    return 9 /* napi_status.napi_generic_failure */;
                },
                remove: function (id) {
                    var work = emnapiAWST.values[id];
                    if (!work)
                        return;
                    if (emnapiNodeBinding) {
                        emnapiNodeBinding.node.emitAsyncDestroy({
                            asyncId: work.asyncId,
                            triggerAsyncId: work.triggerAsyncId
                        });
                    }
                    emnapiAWST.values[id] = undefined;
                    emnapiAWST.idGen.reuse(id);
                }
            };
            /** @__sig vppdp */
            function _emnapi_node_emit_async_init(async_resource, async_resource_name, trigger_async_id, result) {
                if (!emnapiNodeBinding)
                    return;
                var resource = emnapiCtx.handleStore.get(async_resource).value;
                var resource_name = emnapiCtx.handleStore.get(async_resource_name).value;
                var asyncContext = emnapiNodeBinding.node.emitAsyncInit(resource, resource_name, trigger_async_id);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var asyncId = asyncContext.asyncId;
                var triggerAsyncId = asyncContext.triggerAsyncId;
                if (result) {
                    var HEAP_DATA_VIEW = new DataView(wasmMemory.buffer);
                    HEAP_DATA_VIEW.setFloat64(result, asyncId, true);
                    HEAP_DATA_VIEW.setFloat64(result + 8, triggerAsyncId, true);
                }
            }
            /** @__sig vdd */
            function _emnapi_node_emit_async_destroy(async_id, trigger_async_id) {
                if (!emnapiNodeBinding)
                    return;
                emnapiNodeBinding.node.emitAsyncDestroy({
                    asyncId: async_id,
                    triggerAsyncId: trigger_async_id
                });
            }
            /* vpddp export function _emnapi_node_open_callback_scope (async_resource: napi_value, async_id: double, trigger_async_id: double, result: Pointer<int64_t>): void {
              if (!emnapiNodeBinding || !result) return
              const resource = emnapiCtx.handleStore.get(async_resource)!.value
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              const nativeCallbackScopePointer = emnapiNodeBinding.node.openCallbackScope(resource, {
                asyncId: async_id,
                triggerAsyncId: trigger_async_id
              })
        
              from64('result')
              $_TODO_makeSetValue('result', 0, 'nativeCallbackScopePointer', 'i64')
            }
        
            vp
            export function _emnapi_node_close_callback_scope (scope: Pointer<int64_t>): void {
              if (!emnapiNodeBinding || !scope) return
              from64('scope')
              const nativeCallbackScopePointer = $_TODO_makeGetValue('scope', 0, 'i64')
              emnapiNodeBinding.node.closeCallbackScope(BigInt(nativeCallbackScopePointer))
            } */
            /** @__sig ipppppddp */
            function _emnapi_node_make_callback(env, async_resource, cb, argv, size, async_id, trigger_async_id, result) {
                var i = 0;
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var v;
                if (!emnapiNodeBinding)
                    return;
                var resource = emnapiCtx.handleStore.get(async_resource).value;
                var callback = emnapiCtx.handleStore.get(cb).value;
                size = size >>> 0;
                var arr = Array(size);
                var HEAP_DATA_VIEW = new DataView(wasmMemory.buffer);
                for (; i < size; i++) {
                    var argVal = HEAP_DATA_VIEW.getUint32(argv + i * 4, true);
                    arr[i] = emnapiCtx.handleStore.get(argVal).value;
                }
                var ret = emnapiNodeBinding.node.makeCallback(resource, callback, arr, {
                    asyncId: async_id,
                    triggerAsyncId: trigger_async_id
                });
                if (result) {
                    var envObject = emnapiCtx.envStore.get(env);
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    v = envObject.ensureHandleId(ret);
           